--[[ VARIABLES ]]--
local scm = {
    -- START SCREEN --
    startbg = 1;
    starttxt = 256;
    starthigh = 8;
    starthightxt = 128;
    startbut = 256;
    startbutexit = 8;
    startbuttxt = 128;

    -- EDITING --
    bg = 128;
    txt = 1;
    cmt = 32;
    con = 2;
    func = 8;
    str = 16384;
    sta = 512;
    selLn = 256;
    sel = 8;

    -- LINE NUMBERS --
    lnumbg = 256;
    lnumsel = 128;
    lnumtxt = 128;
    lnumtxtSel = 1;

    -- UPPER BAR --
    bartop = 256;
    bartoptxt = 1;
    buttop = 256;
    buttopsel = 8;
    placeholder1 = 8;
    placeholder2 = 256;
    selIcon = 8;
}

local prg = {
    fl = {
        apis = "/.xedit/apis/";
        proj = "/.xedit/projects/";
        dumps = "/.xedit/dumps/";
        schemes = "/.xedit/schemes/";
        config = "/.xedit/config";
        crash = "/.xedit/crash/";
    };

    xPos = 1;
    xScroll = 0;
    yPos = 1;
    yScroll = 0;

    sel = {
        x1 = 0;
        x2 = 0;
        y1 = 0;
        y2 = 0;
    };

    lastScroll = {
        x1 = 0;
        y1 = 0;
    };

    ev = {
    };

    clbrd = {
    };

    offTop = 1;
    butwidth = 7;
    submenuWidth = 15;
    tabWidth = 2;
    scrollWait = 0.5;
    scrollInt = 0.05;
    shortcutInt = 0.2;
    selecDrawn = false;
    version = "1.0pr";

    keywords = {
        ["function"] = scm.con;
        ["if"] = scm.con;
        ["for"] = scm.con;
        ["repeat"] = scm.con;
        ["while"] = scm.con;
        ["until"] = scm.con;
        ["and"] = scm.con;
        ["or"] = scm.con;
        ["else"] = scm.con;
        ["elseif"] = scm.con;
        ["in"] = scm.con;
        ["do"] = scm.con;
        ["then"] = scm.con;
        ["break"] = scm.con;
        ["return"] = scm.con;
        ["end"] = scm.con;
        ["local"] = scm.con;
        ["not"] = scm.con;

        ["true"] = scm.sta;
        ["false"] = scm.sta;
        ["nil"] = scm.sta;

        ["write"] = scm.func;
        ["print"] = scm.func;
        ["pairs"] = scm.func;
        ["ipairs"] = scm.func;
        ["sleep"] = scm.func;
        ["loadstring"] = scm.func;
        ["loadfile"] = scm.func;
        ["dofile"] = scm.func;
        ["rawset"] = scm.func;
        ["rawget"] = scm.func;
        ["setfenv"] = scm.func;
        ["getfenv"] = scm.func;
    };

    autoComplete = {
        ["\""] = "\"";
        ["\'"] = "\'";
        ["("] = ")";
        ["{"] = "}";
        ["["] = "]";
    };

    autoIndent = {
        "if%s+.+%s+then%s*$";
        "while%s+.+%s+do%s*$";
        "for%s+.+%s+do%s*$";
        "repeat%s*$";
        "function%s+[%w_]*%s*%(.*%)%s*$";
    };

    hitmap = {
    };
}
--[[ VARIABLES END ]]--


--[[ FUNCTIONS ]]--
local function resolvePath( path )
    return ( "/" .. path ):gsub( "/+", "/" ):gsub( "\\+", "/" )
end

local function writeFile( text, path )
    path = resolvePath( path )

    if not fs.isReadOnly( path ) then
        local rawpath = path:match( "^.+/" )

        if rawpath then
            if not fs.exists( rawpath ) or not fs.isDir( rawpath ) then
                fs.delete( rawpath )
                fs.makeDir( rawpath )
            end
        end

        local f = fs.open( path, "w" )

        if f then
            for _, v in pairs( text ) do
                f.writeLine( v )
            end

            f.close()
            return true
        end

        return false, "Failed to open file"
    end

    return false, "Path is ReadOnly"
end

local function getTable( path )
    path = resolvePath( path )

    if fs.exists( path ) then
        local f = fs.open( path, "r" )

        if f then
            local file = {
            }
            local ln = f.readLine()

            while ln do
                file[#file+1] = ln
                ln = f.readLine()
            end

            f.close()

            return file
        end

        return { "" }
    end

    return { "" }
end

local function loadAPI( path )
    local func, err = loadfile( resolvePath( path ) )

    if func then
        local env = {}
        setfenv( func, setmetatable( env, { __index=_G } ) )

        func()

        return env
    else
        error( "Failed to load API @" .. path .. " - There seems to be something wrong with your installation")
    end
end

local function pastebin( arg )
    local function formatText( txt )
        local new = ""

        for k, v in pairs( txt ) do
            new = new .. v .. "\n"
        end

        return new
    end

    if http then
        if arg.action == "put" then
            local response = http.post(
                "http://www.pastebin.com/api/api_post.php",
                "api_option=paste&api_dev_key=65ea67d061b102aa026db0f77a948b01" ..
                "&api_paste_format=lua&api_paste_name=" .. textutils.urlEncode( arg.name ) ..
                "&api_paste_code=" .. textutils.urlEncode( formatText( arg.txt ) ) ..
                "&api_paste_expire_date=10M"
            )

            if response then
                return response.readAll():match( "[^/]+$" ), response.close()
            else
                return false, "Failed"
            end
        elseif arg.action == "get" then
            local response = http.get( "http://www.pastebin.com/raw.php?i=" .. arg.id )

            if response then
                local new, ln = {}, response.readLine()

                while ln do
                    new[#new+1] = ln
                    ln = response.readLine()
                end

                response.close()
                return new
            else
                return false, "Failed"
            end
        end
    else
        return false, "HTTP not enabled"
    end
end

local function findString( txt, char )
    if txt:sub( 1, 1 ) == char and #txt > 1 then
        local sub = txt:gsub( "\\\\", "  " )

        for i = 2, #sub do
            if sub:sub( i, i ) == char and sub:sub( i-1, i-1 ) ~= "\\" then
                return txt:sub( 1, i )
            end
        end
    end
end

local function writePart( txt, pattern, color, line, bg )
    local match

    if type( pattern ) == "string" then
        match = txt:match( pattern )
    else
        match = pattern()
    end

    if match then
        if type( color ) == "number" then
            term.setTextColor( color )
        else
            term.setTextColor( color( match ) )
        end

        local x1, matchLen = #prg.file[line] - #txt + 1, #match
        local sub = match

        if line > prg.sel.y1 and line <= prg.sel.y2 then
            term.setBackgroundColor( scm.sel )

            if line == prg.sel.y2 then
                local len = prg.sel.x2-x1+1
                sub = match:sub( 1, len > 0 and len or 0 )
            else
                sub = match
            end

            term.write( sub )
            term.setBackgroundColor( bg )
            term.write( match:sub( #sub+1 ) )
        elseif line == prg.sel.y1 then
            local len = prg.sel.x1-x1
            sub = match:sub( 1, len > 0 and len or 0 )
            term.write( sub )
            match = match:sub( #sub+1 )

            if prg.sel.y1 == prg.sel.y2 then
                local len = prg.sel.x2-x1-( matchLen-#match )+1
                sub = match:sub( 1, len > 0 and len or 0  )
                term.setBackgroundColor( scm.sel )
                term.write( sub )
                term.setBackgroundColor( bg )
                term.write( match:sub( #sub+1 ) )
            elseif #match > 0 then
                term.setBackgroundColor( scm.sel )
                term.write( match )
                term.setBackgroundColor( scm.bg )
            end
        else
            term.write( match )
        end

        return txt:sub( matchLen+1 )
    end
end

local function writeLine( y1, bg )
    local txt = prg.file[y1]

    while #txt > 0 do
        txt =
        writePart( txt, "^%-%-%[%[.-%]%]", scm.cmt, y1, bg ) or
        writePart( txt, "^%-%-.*", scm.cmt, y1, bg ) or
        writePart( txt, function() return findString( txt, "\"" ) end, scm.str, y1, bg ) or
        writePart( txt, function() return findString( txt, "\'" ) end, scm.str, y1, bg ) or
        writePart( txt, "^%[%[.-%]%]", scm.str, y1, bg ) or
        writePart( txt, "^[%w_]+",
            function( match )
                return prg.keywords[match] or scm.txt
            end, y1, bg ) or
        writePart( txt, "^[^%w_]", scm.txt, y1, bg )
    end
end

local function barTop()
    term.setCursorPos( 1, 1 )
    term.setBackgroundColor( scm.bartop )
    term.clearLine()

    for k, v in pairs( prg.hitmap ) do
        if v.isElement then
            v:draw()
        end
    end
end

local function writeAtPos( y1 )
    local width = #tostring( #prg.file )+1
    local lineSelected = prg.yScroll+prg.yPos == prg.yScroll+y1-prg.offTop

    term.setCursorPos( 1, y1 )
    term.setBackgroundColor( lineSelected and scm.selLn or scm.bg )
    term.clearLine()
    term.setCursorPos( width-prg.xScroll+1, y1 )
    writeLine( prg.yScroll+y1-prg.offTop, lineSelected and scm.selLn or scm.bg )
    term.setCursorPos( 1, y1 )
    term.setBackgroundColor( lineSelected and scm.lnumsel or scm.lnumbg )
    term.setTextColor( lineSelected and scm.lnumtxtSel or scm.lnumtxt )
    term.write( ( " " ):rep( width-#tostring( prg.yScroll+y1-prg.offTop )-1 ) .. prg.yScroll+y1-prg.offTop .. " " )
    term.setTextColor( scm.txt )
end

local function editGUI()
    if #prg.file < prg.ySize+prg.yScroll-prg.offTop then
        term.setBackgroundColor( scm.bg )
        for i = #prg.file+prg.offTop-prg.yScroll+1, prg.ySize do
            term.setCursorPos( 1, i )
            term.write( ( " " ):rep( prg.xSize ) )
        end
    end

    for i = 1, prg.ySize-prg.offTop do
        if prg.yScroll+i-1 < #prg.file then
            writeAtPos( i+prg.offTop )
        end
    end
end

local function initialize()
    local buttons, menus = {
        "File";
        "Edit";
        "Document";
        "NYI";
    }, {
        file = {
            { "save"; "Save" };
            { "pastebin"; "Pastebin"};
            { "saveExit"; "Save & Exit" };
            { "exit"; "Exit" };
        };

        edit = {
            { "copy"; "Copy" };
            { "cut"; "Cut" };
            { "delete"; "Delete" };
            { "paste"; "Paste" };
        };

        document = {
            { "goto1"; "Go To Ln1" };
            { "gotopos"; "Go To Pos" };
            { "gotoend"; "Go To End" };
        };

        nyi = {
            { "run"; "Run Program" };
            { "runArgs", "Run w/ args" };
        };
    }

    for k, v in pairs( prg.fl ) do
        if v:sub( #v ) == "/" then
            local path = v:sub( 1, #v-1 )

            if not fs.exists( path ) then
                fs.makeDir( path )
            elseif not fs.isDir( path ) then
                fs.delete( path )
                fs.makeDir( path )
            end
        end
    end

    prg.gui = loadAPI( prg.fl.apis .. "gui" )

    for k, v in pairs( buttons ) do
        local itr1, x1, x2 = 0, ( k-1 )*prg.butwidth+k, ( k-1 )*prg.butwidth+prg.submenuWidth+k-1
        prg.hitmap[v:lower()] = prg.gui.button( { x1=2+( k-1 )*prg.butwidth+( k-1 ); x2=( k-1 )+k*prg.butwidth+1; y1=1; y2=1; bg=scm.buttop; txt={ { txt=v; pos="l"; fg=scm.bartoptxt } } } )
        prg.hitmap[v:lower() .. "Menu"] = {}


        for k1, v1 in pairs( menus[v:lower()] ) do
            if k1 == 1 then
                prg.hitmap[v:lower() .. "Menu"].spacer1 = prg.gui.button( { x1=x2 <= prg.xSize and x1 or x1-( prg.xSize-x2 ); x2=math.min( x2, prg.xSize ); y1=2; y2=2; bg=scm.placeholder1 } )
            end

            prg.hitmap[v:lower() .. "Menu"][v1[1]] = prg.gui.button( { x1=x2 <= prg.xSize and x1 or x1-( prg.xSize-x2 ); x2=math.min( x2, prg.xSize ); y1=3+itr1; y2=3+itr1; bg=scm.buttop; txt={ { txt=v1[2]; pos="l"; fg=scm.bartoptxt } } } )

            if k1 == #menus[v:lower()] then
                prg.hitmap[v:lower() .. "Menu"].spacer2 = prg.gui.button( { x1=x2 <= prg.xSize and x1 or x1-( prg.xSize-x2 ); x2=math.min( x2, prg.xSize ); y1=4+itr1; y2=4+itr1; bg=scm.placeholder2 } )
            end

            itr1 = itr1 + 1
        end
    end
end

local function setCursor( x1, y1, forceLine, forceWhole, forceHidden, forceAll )
    local wholeRefresh, lineRefresh, needXRefresh

    if y1 and y1 ~= prg.yScroll+prg.yPos then
        local samePos, change = prg.yScroll+prg.yPos == y1, prg.yScroll+prg.yPos
        if y1 < prg.yScroll+1 then
            prg.yPos = 1
            prg.yScroll = y1 > 0 and y1-1 or 0
            wholeRefresh = change ~= prg.yScroll+prg.yPos
        elseif y1 > prg.yScroll+prg.ySize-prg.offTop then
            prg.yPos = math.min( #prg.file, prg.ySize-prg.offTop )
            prg.yScroll = math.min( y1, #prg.file )-prg.yPos
            wholeRefresh = change ~= prg.yScroll+prg.yPos == y1
        else
            local oldPos = prg.yPos
            prg.yPos = math.min( y1-prg.yScroll, #prg.file-prg.yScroll )

            if change ~= prg.yScroll+prg.yPos then
                if #prg.file >= prg.yScroll+oldPos then
                    writeAtPos( oldPos+prg.offTop )
                else
                    wholeRefresh = true
                end
                lineRefresh = true
            end
        end

        if change ~= prg.yScroll+prg.yPos then
            needXRefresh = true
        end
    end

    if x1 ~= prg.xPos+prg.xScroll or needXRefresh or forceHidden or forceAll or forceWhole then
        local change = not forceAll or prg.xScroll+prg.xPos
        local width = #tostring( #prg.file )+1

        if x1 < prg.xScroll+1 then
            prg.xPos = 1
            prg.xScroll = x1 > 0 and x1-1 or 0
            wholeRefresh = change ~= prg.xScroll+prg.xPos
        elseif x1 > prg.xScroll+prg.xSize-width then
            prg.xPos = math.min( #prg.file[prg.yScroll+prg.yPos]+1, prg.xSize-width )
            prg.xScroll = math.min( x1, #prg.file[prg.yScroll+prg.yPos]+1 )-prg.xPos
            wholeRefresh = change ~= prg.xScroll+prg.xPos
        else
            local overhang = prg.xScroll > #prg.file[prg.yScroll+prg.yPos]
            prg.xPos = overhang and 1 or math.min( x1-prg.xScroll, #prg.file[prg.yScroll+prg.yPos]-prg.xScroll+1 )

            if change ~= prg.xScroll+prg.xPos and overhang then
                prg.xScroll = #prg.file[prg.yScroll+prg.yPos]
                wholeRefresh = true
            end
        end
    end

    if ( wholeRefresh or forceWhole ) and not forceHidden then
        editGUI()
    elseif ( lineRefresh or forceLine ) and not forceHidden then
        writeAtPos( prg.yPos+prg.offTop )
    end
end

local function deleteSelection()
    if prg.sel.x1 == 0 then
        return
    end

    local lineRemoval
    for i = prg.sel.y2, prg.sel.y1, -1 do
        if i == prg.sel.y2 then
            if i == prg.sel.y1 then
                prg.file[i] = prg.file[i]:sub( 1, prg.sel.x1-1 ) .. prg.file[i]:sub( prg.sel.x2+1 )
            else
                lineRemoval = prg.file[i]:sub( prg.sel.x2+1 )
                table.remove( prg.file, i )
            end
        elseif i == prg.sel.y1 then
            prg.file[i] = prg.file[i]:sub( 1, prg.sel.x1-1 ) .. lineRemoval
        else
            table.remove( prg.file, i )
        end
    end

    setCursor( prg.sel.x1, prg.sel.y1, false, false, true )
    prg.sel.x1, prg.sel.x2, prg.sel.y1, prg.sel.y2 = 0, 0, 0, 0
end

local function copySelection()
    if prg.sel.x1 == 0 then
        return
    end

    prg.clbrd = {}

    for i = prg.sel.y1, prg.sel.y2 do
        if i == prg.sel.y1 then
            prg.clbrd[#prg.clbrd+1] = prg.file[i]:sub( prg.sel.x1, i == prg.sel.y2 and prg.sel.x2 or nil )
        elseif i == prg.sel.y2 then
            prg.clbrd[#prg.clbrd+1] = prg.file[i]:sub( 1, prg.sel.x2 )
        else
            prg.clbrd[#prg.clbrd+1] = prg.file[i]
        end
    end
end

local function pasteSelection()
    if prg.sel.x1 ~= 0 then
        deleteSelection()
    end

    if #prg.clbrd == 0 then
        return
    end

    local cut = prg.file[prg.yScroll+prg.yPos]:sub( prg.xScroll+prg.xPos )
    prg.file[prg.yScroll+prg.yPos] = prg.file[prg.yScroll+prg.yPos]:sub( 1, prg.xScroll+prg.xPos-1 )

    for k, v in pairs( prg.clbrd ) do
        if k == 1 then
            if #prg.clbrd > 1 then
                prg.file[prg.yScroll+prg.yPos] = prg.file[prg.yScroll+prg.yPos] .. v
            else
                prg.file[prg.yScroll+prg.yPos] = prg.file[prg.yScroll+prg.yPos] .. v .. cut
            end
        elseif k < #prg.clbrd then
            table.insert( prg.file, prg.yScroll+prg.yPos+k-1, v )
        else
            table.insert( prg.file, prg.yScroll+prg.yPos+k-1, v .. cut )
        end
    end

    setCursor( prg.xScroll+prg.xPos+#( prg.clbrd[#prg.clbrd] or "" ), prg.yScroll+prg.yPos+#prg.clbrd-1, false, false, true )
end

local function drawSelec( state )
    if state then
        term.setCursorPos( prg.xSize, 1 )
        term.setBackgroundColor( scm.selIcon )
        term.write( " " )
        prg.selecDrawn = true
    else
        term.setCursorPos( prg.xSize, 1 )
        term.setBackgroundColor( scm.bartop )
        term.write( " " )
        prg.selecDrawn = false
    end
end

local function handleEvents( arg, width, timerOnly )
    if arg[1] == "timer" then
        if arg[2] == prg.ev.autosave then
            fwrite( prg.file, prg.fl.dumps .. prg.path:match( "[^/\\]+$" ) )
        elseif arg[2] == prg.ev.scrollWait then
            prg.ev.scrollInt = os.startTimer( 0 )
        elseif arg[2] == prg.ev.scrollInt and not timerOnly then
            if prg.yPos == 1 and prg.yScroll > 0 then
                prg.yScroll = prg.yScroll - 1
                editGUI()
                prg.ev.scrollInt = os.startTimer( prg.scrollInt )
            elseif prg.yPos == prg.ySize-prg.offTop and prg.yScroll < #prg.file-prg.ySize+prg.offTop then
                prg.yScroll = prg.yScroll + 1
                editGUI()
                prg.ev.scrollInt = os.startTimer( prg.scrollInt )
            elseif prg.xPos == 1 and prg.xScroll > 0 then
                prg.xScroll = prg.xScroll - 1
                editGUI()
                prg.ev.scrollInt = os.startTimer( prg.scrollInt )
            elseif prg.xPos == prg.xSize-width and prg.xScroll < #prg.file[prg.yScroll+prg.yPos]-prg.xSize+width+1 then
                prg.xScroll = prg.xScroll + 1
                editGUI()
                prg.ev.scrollInt = os.startTimer( prg.scrollInt )
            end
        elseif arg[2] == prg.ev.shorcutShift then
            prg.ev.shortcutShift = nil
        elseif arg[2] == prg.ev.shortcutCtrl then
            prg.ev.shortcutCtrl = nil
        end
    end
end

local function fileMenu()
    prg.hitmap.file.bg = scm.buttopsel
    prg.hitmap.file:draw()
    term.setCursorBlink( false )

    for k, v in pairs( prg.hitmap.fileMenu ) do
        v:draw()
    end

    while true do
        local e = { coroutine.yield() }

        if e[1] == "mouse_click" then
            local hits = prg.gui.checkHitmap( { hitmap=prg.hitmap, x1=e[3], y1=e[4] } )

            if hits.fileMenu.save then
                fs.delete( prg.fl.dumps .. prg.path:match( "[^/\\]+$" ) )
                writeFile( prg.file, prg.path )
                break
            elseif hits.fileMenu.pastebin then
                local ok, err = pastebin( { action="put", name=prg.path:match( "[^/\\]+$" ), txt=prg.file } )

                if not ok then
                    table.insert( prg.file, 1, "-- An error occured ( " .. err .. " ) --" )
                else
                    table.insert( prg.file, 1, "-- Success. Pastebin code: " .. ok .. " --")
                end

                break
            elseif hits.fileMenu.saveExit then
                fs.delete( prg.fl.dumps .. prg.path:match( "[^/\\]+$" ) )
                writeFile( prg.file, prg.path )
                prg.running = false
                break
            elseif hits.fileMenu.exit then
                prg.running = false
                break
            elseif hits.file then
                break
            elseif not ( hits.fileMenu.spacer1 or hits.fileMenu.spacer2 ) then
                os.queueEvent( unpack( e ) )
                break
            end
        end
    end

    prg.hitmap.file.bg = scm.buttop
    prg.hitmap.file:draw()
    editGUI()
    term.setCursorBlink( true )
end

local function editMenu()
    prg.hitmap.edit.bg = scm.buttopsel
    prg.hitmap.edit:draw()
    term.setCursorBlink( false )

    for k, v in pairs( prg.hitmap.editMenu ) do
        v:draw()
    end

    while true do
        local e = { coroutine.yield() }

        if e[1] == "mouse_click" then
            local hits = prg.gui.checkHitmap( { hitmap=prg.hitmap, x1=e[3], y1=e[4] } )

            if hits.editMenu.copy then
                copySelection()
                break
            elseif hits.editMenu.cut then
                copySelection()
                deleteSelection()
                break
            elseif hits.editMenu.delete then
                deleteSelection()
                break
            elseif hits.editMenu.paste then
                pasteSelection()
                break
            elseif hits.edit then
                break
            elseif not ( hits.editMenu.spacer1 or hits.editMenu.spacer2 ) then
                os.queueEvent( unpack( e ) )
                break
            end
        end
    end

    prg.hitmap.edit.bg = scm.buttop
    prg.hitmap.edit:draw()
    editGUI()
    term.setCursorBlink( true )
end

local function docMenu()
    local keyEvents, readPos
    prg.hitmap.document.bg = scm.buttopsel
    prg.hitmap.document:draw()
    term.setCursorBlink( false )

    for k, v in pairs( prg.hitmap.documentMenu ) do
        v:draw()
    end

    while true do
        local e = { coroutine.yield() }

        if e[1] == "mouse_click" and not keyEvents then
            local hits = prg.gui.checkHitmap( { hitmap=prg.hitmap, x1=e[3], y1=e[4] } )

            if hits.documentMenu.goto1 then
                setCursor( 1, 1, false, false, true )
                break
            elseif hits.documentMenu.gotopos then
                readPos, keyEvents = prg.gui.read( {
                    x1=hits.documentMenu.gotopos.x1+1,
                    x2=hits.documentMenu.gotopos.x2-1,
                    y1=hits.documentMenu.gotopos.y1,
                    bg=scm.buttop,
                    filter=function( txt ) return tonumber( txt ) end
                } ), true

                readPos:draw()
                term.setCursorBlink( true )
            elseif hits.documentMenu.gotoend then
                setCursor( #prg.file[#prg.file]+1, #prg.file, false, false, true )
                break
            elseif hits.document then
                break
            elseif not ( hits.documentMenu.spacer1 or hits.documentMenu.spacer2 ) then
                os.queueEvent( unpack( e ) )
                break
            end
        elseif e[1] == "advread_complete" then
            setCursor( 1, tonumber( e[2] ), false, false, true )
            break
        elseif keyEvents then
            readPos:evhandle( unpack( e ) )
        end
    end

    prg.hitmap.document.bg = scm.buttop
    prg.hitmap.document:draw()
    editGUI()
    term.setCursorBlink( true )
end

local function runProgram( file, ... )
    local code = table.concat( file, "\n" )

    local func, err = loadstring( code )

    if func then
        local env = setmetatable( {}, { __index = _G } )
        setfenv( func, env )
        func = coroutine.create( func )

        term.setBackgroundColor( 32768 )
        term.clear()
        term.setCursorPos( 1, 1 )

        local _, cErr = coroutine.resume( func, ... )

        while coroutine.status( func ) ~= "dead" do
            local e = { coroutine.yield() }

            handleEvents( e, false, true )

            coroutine.resume( func, unpack( e ) )
        end

        if cErr then
            return false, cErr
        else
            print( "Press any key or click to return to luaedit" )

            while true do
                local e = { coroutine.yield() }

                handleEvents( e, false, true )

                if e[1] == "char" or e[1] == "mouse_click" then
                    break
                end
            end

            return true
        end
    end

    return false, err
end

local function runMenu()
    local keyEvents, readPos
    prg.hitmap.run.bg = scm.buttopsel
    prg.hitmap.run:draw()
    term.setCursorBlink( false )

    for k, v in pairs( prg.hitmap.runMenu ) do
        v:draw()
    end

    while true do
        local e = { coroutine.yield() }

        if e[1] == "mouse_click" then
            local hits = prg.gui.checkHitmap( { x1=e[3]; y1=e[4]; hitmap=prg.hitmap } )

            if hits.runMenu.run then
                local success, err = runProgram( prg.file )
                barTop()
                break
            elseif hits.runMenu.runArgs then
                readPos, keyEvents = prg.gui.read( {
                    x1=hits.runMenu.runArgs.x1+1;
                    x2=hits.runMenu.runArgs.x2-1;
                    y1=hits.runMenu.runArgs.y1;
                    y2=hits.runMenu.runArgs.y2;
                    bg=scm.buttop;
                } ), true

                readPos:draw()
                term.setCursorBlink( true )
            elseif hits.run then
                break
            elseif not ( hits.runMenu.spacer1 or hits.runMenu.spacer2 ) then
                os.queueEvent( unpack( e ) )
                break
            end
        elseif e[1] == "advread_complete" then
            local args, quoted = {}, false

            term.setCursorBlink( false )

            for match in ( e[2] .. "\"" ):gmatch( "(.-)\"" ) do
                if quoted then
                    args[#args+1] = match
                else
                    for match1 in match:gmatch( "%S+" ) do
                        args[#args+1] = match1
                    end
                end

                quoted = not quoted
            end
            local success, err = runProgram( prg.file, unpack( args ) )
            barTop()
            break
        elseif keyEvents then
            readPos:evhandle( unpack( e ) )
        end
    end

    prg.hitmap.run.bg = scm.buttop
    prg.hitmap.run:draw()
    editGUI()
    term.setCursorBlink( true )
end

local function startScreen()
    local x, y = math.ceil( prg.xSize/2 ), math.ceil( prg.ySize/2 )

    local mainMenu, pastebinMenu = {
        input = prg.gui.read( { x1=4; x2=x-3; y1=5; bg=scm.startbg; fg=scm.starttxt } );
        pastebin = prg.gui.button( { x1=2; x2=x-2; y1=12; y2=14; bg=scm.startbut; txt={ { txt="Open from Pastebin"; pos="l"; fg=scm.startbuttxt } } } );
        exit = prg.gui.button( { x1=2; x2=x-2; y1=16; y2=18; bg=scm.starbutexit; txt={ { txt="Exit"; pos="l"; fg=scm.startbuttxt } } } );
    }, {
        file = prg.gui.read( { x1=4; x2=x-3; y1=5; bg=scm.startbg; fg=scm.starttxt } );
        id = prg.gui.read( { x1=x+3; x2=prg.xSize-2; y1=5; bg=scm.startbg; fg=scm.starttxt } );
        mainMenu = prg.gui.button( { x1=2; x2=x-2; y1=16; y2=18; bg=scm.startbutexit; txt={ { txt="Main menu"; pos="l"; fg=scm.startbuttxt } } } );
        submit = prg.gui.button( { x1=x+2; x2=prg.xSize-1; y1=16; y2=18; bg=scm.startbut; txt={ { txt="Submit"; pos="l"; fg=scm.startbuttxt } } } );
    }

    local active, currInput = mainMenu, mainMenu.input


    local function clearScreen()
        term.setBackgroundColor( scm.startbg )
        term.clear()
        prg.gui.rectangle( 8, 2, prg.xSize, 2, scm.starthigh )
        term.setTextColor( scm.starthightxt )
        prg.gui.advPrint( "Welcome to xEdit", 2, "l", 8 )
        term.setBackgroundColor( scm.startbg )
        term.setTextColor( scm.starttxt )
    end

    local function drawMainMenu()
        term.setCursorPos( 3, 5 )
        term.write( "/" )
        prg.gui.advPrint( "Open file or", 9, "c", 1, x-1 )
        prg.gui.rectangle( x, 4, x, prg.ySize-1, scm.startbg, "|", scm.starttxt )
        prg.gui.rectangle( 3, 7, x-3, 7, scm.startbg, "-", scm.starttxt )

        for k, v in pairs( mainMenu ) do
            v:draw()
        end

        currInput:drawCursor()
    end

    local function drawPastebin()
        prg.gui.advPrint( "Specify path", 9, "c", 1, x-1)
        prg.gui.advPrint( "Pastebin ID", 9, "c", x+1, prg.xSize )
        prg.gui.rectangle( 3, 7, x-3, 7, scm.startbg, "-", scm.starttxt )
        prg.gui.rectangle( x+3, 7, prg.xSize-2, 7, scm.startbg, "-", scm.starttxt )
        term.setCursorPos( 3, 5 )
        term.write( "/" )
        prg.gui.rectangle( x, 4, x, prg.ySize-1, scm.startbg, "|", scm.starttxt )

        for k, v in pairs( pastebinMenu ) do
            v:draw()
        end

        currInput:drawCursor()
    end

    clearScreen()
    drawMainMenu()
    term.setCursorBlink( true )

    while true do
        local e = { coroutine.yield() }

        currInput:evhandle( unpack( e ) )

        if e[1] == "mouse_click" then
            local hits = prg.gui.checkHitmap( { x1=e[3]; y1=e[4]; hitmap=active } )

            if hits.pastebin then
                active = pastebinMenu
                currInput = pastebinMenu.file
                clearScreen()
                drawPastebin()
            elseif hits.mainMenu then
                active = mainMenu
                currInput = mainMenu.input
                clearScreen()
                drawMainMenu()
            elseif hits.exit then
                break
            elseif hits.id and currInput ~= hits.id then
                currInput = hits.id
                currInput:drawCursor()
            elseif hits.file and currInput ~= hits.file then
                currInput = hits.file
                currInput:drawCursor()
            elseif hits.submit then
                local path = resolvePath( pastebinMenu.file.txt )

                if #path > 1 then
                    term.setCursorBlink( false )
                    pastebinMenu.submit:setLine( { index=1; txt="Connecting..." } )
                    pastebinMenu.submit:draw()

                    local resp, err = pastebin( { action="get"; id=pastebinMenu.id.txt } )

                    if not resp then
                        pastebinMenu.submit:setLine( { index=1; txt=err } )
                        pastebinMenu.submit:draw()
                        sleep( 2 )
                        pastebinMenu.submit:setLine( { index=1; txt="Submit" } )
                        pastebinMenu.submit:draw()
                        currInput:drawCursor()
                        term.setCursorBlink( true )
                    else
                        prg.path = path
                        prg.file = resp
                        prg.running = true
                        break
                    end
                end
            end
        elseif e[1] == "advread_complete" and currInput == mainMenu.input then
            local path = resolvePath( e[2] )

            if #path > 1 then
                prg.path = path
                prg.file = getTable( path )
                prg.running = true
                break
            end
        elseif e[1] == "key" and e[2] == 28 then
            if currInput == pastebinMenu.file then
                currInput = pastebinMenu.id
                currInput:drawCursor()
            elseif currInput == pastebinMenu.id then
                os.queueEvent( "mouse_click", 1, pastebinMenu.submit.x1, pastebinMenu.submit.y1 )
            end
        end
    end
end

local function exitScreen()
    term.setBackgroundColor( 32768 )
    term.clear()
    prg.gui.rectangle( 8, 2, prg.xSize, 2, scm.starthigh )
    term.setTextColor( scm.starthightxt )
    prg.gui.advPrint( "Thanks for using xEdit v" .. prg.version, 2, "l", 8 )
    term.setTextColor( 1 )
    term.setBackgroundColor( 32768 )
    term.setCursorPos( 1, 4 )
end
--[[ FUNCTIONS END ]]--


--[[ INITIALIZE ]]--
if term.isColor() then
    local tArgs = { ... }
    prg.xSize, prg.ySize = term.getSize()
    prg.gui = loadAPI( prg.fl.apis .. "gui" )
    initialize()

    if tArgs[1] then
        local path = resolvePath( tArgs[1] )
        prg.path = #path > 1 and path
        prg.file = getTable( path )
        prg.running = true
    else
        startScreen()
    end
else
    print( "Sorry, this program is only for advanced computers" )
end
--[[ INITIALIZE END ]]--


--[[ MAIN LOOP ]]--
local function main()
    barTop()
    editGUI()
    term.setCursorBlink( true )
    while prg.running do
        local width = #tostring( #prg.file )+1

        if prg.sel.x1 ~= 0 and not prg.selecDrawn then
            drawSelec( true )
        elseif prg.sel.x1 == 0 and prg.selecDrawn then
            drawSelec()
        end

        term.setCursorPos( width+prg.xPos, prg.yPos+prg.offTop )

        e = { coroutine.yield() }

        handleEvents( e, width )

        if e[1] == "char" then
            local forceWhole, cancel, currChar, prevChar = nil,
                nil,
                prg.file[prg.yScroll+prg.yPos]:sub( prg.xScroll+prg.xPos, prg.xScroll+prg.xPos ),
                prg.file[prg.yScroll+prg.yPos]:sub( prg.xScroll+prg.xPos-1, prg.xScroll+prg.xPos-1 )

            if prg.sel.x1 ~= 0 then
                deleteSelection()
                forceWhole = true
            end

            for k, v in pairs( prg.autoComplete ) do
                if currChar == v and e[2] == v and prevChar ~= "\\" then
                    cancel = true
                    break
                elseif e[2] == k and prevChar ~= "\\" then
                    e[2] = e[2] .. v
                    break
                end
            end

            if not cancel then
                prg.file[prg.yPos+prg.yScroll] = prg.file[prg.yPos+prg.yScroll]:sub( 1, prg.xPos+prg.xScroll-1 ) .. e[2] .. prg.file[prg.yPos+prg.yScroll]:sub( prg.xPos+prg.xScroll )
            end

            setCursor( prg.xPos+prg.xScroll+1, false, true, forceWhole )
        elseif e[1] == "key" then
            if e[2] == 14 then
                if prg.sel.x1 ~= 0 then
                    deleteSelection()
                    setCursor( prg.xScroll+prg.xPos, false, false, true )
                elseif prg.xScroll+prg.xPos > 1 then
                    local addChar, prevChar, currChar =
                        0,
                        prg.file[prg.yScroll+prg.yPos]:sub( prg.xScroll+prg.xPos-1, prg.xScroll+prg.xPos-1 ),
                        prg.file[prg.yScroll+prg.yPos]:sub( prg.xScroll+prg.xPos, prg.xScroll+prg.xPos )

                    for k, v in pairs( prg.autoComplete ) do
                        if prevChar == k and currChar == v then
                            addChar = 1
                            break
                        end
                    end

                    prg.file[prg.yScroll+prg.yPos] = prg.file[prg.yScroll+prg.yPos]:sub( 1, prg.xScroll+prg.xPos-2 ) ..
                        prg.file[prg.yScroll+prg.yPos]:sub( prg.xScroll+prg.xPos+addChar )

                    setCursor( prg.xScroll+prg.xPos-1, false, true, forceWhole )
                elseif prg.yScroll+prg.yPos > 1 then
                    local oldLength = #prg.file[prg.yScroll+prg.yPos-1]+1
                    prg.file[prg.yScroll+prg.yPos-1] = prg.file[prg.yScroll+prg.yPos-1] .. prg.file[prg.yScroll+prg.yPos]
                    table.remove( prg.file, prg.yScroll+prg.yPos )
                    setCursor( oldLength, prg.yScroll+prg.yPos-1, false, true )
                end
            elseif e[2] == 15 then
                local forceWhole, spaces, sub = nil, #prg.file[prg.yScroll+prg.yPos]:match( "^%s*" )%prg.tabWidth

                if prg.sel.x1 ~= 0 then
                    deleteSelection()
                    forceWhole = true
                end

                if not prg.ev.shortcutShift then
                    prg.file[prg.yScroll+prg.yPos] = ( " " ):rep( prg.tabWidth-spaces ) .. prg.file[prg.yScroll+prg.yPos]
                    setCursor( prg.xScroll+prg.xPos+prg.tabWidth-spaces, false, true, forceWhole )
                else
                    local spaces = math.min( prg.tabWidth+1, #prg.file[prg.yScroll+prg.yPos]:match( "^%s*" )+1 )
                    prg.file[prg.yScroll+prg.yPos] = prg.file[prg.yScroll+prg.yPos]:sub( spaces )
                    prg.ev.shortcutShift = nil
                    setCursor( prg.xScroll+prg.xPos-spaces+1, false, true, forceWhole )
                end
            elseif e[2] == 28 then

                local addIndent = 0

                if prg.sel.x1 ~= 0 then
                    deleteSelection()
                end

                for k, v in pairs( prg.autoIndent ) do
                    if prg.file[prg.yScroll+prg.yPos]:match( v ) and prg.xScroll+prg.xPos == #prg.file[prg.yScroll+prg.yPos]+1 then
                        addIndent = prg.tabWidth
                        break
                    end
                end

                local spaces = #( prg.xScroll+prg.xPos > prg.tabWidth and prg.file[prg.yScroll+prg.yPos] or "" ):match( "^%s*" )+addIndent

                table.insert( prg.file,
                    prg.yScroll+prg.yPos+1,
                    ( " " ):rep( spaces ) .. prg.file[prg.yScroll+prg.yPos]:sub( prg.xScroll+prg.xPos )
                )

                prg.file[prg.yScroll+prg.yPos] = prg.file[prg.yScroll+prg.yPos]:sub( 1, prg.xScroll+prg.xPos-1 )
                setCursor( spaces+1, prg.yScroll+prg.yPos+1, false, true )
            elseif e[2] == 29 or e[2] == 157 then
                prg.ev.shortcutCtrl = os.startTimer( prg.shortcutInt )
            elseif e[2] == 42 then
                prg.ev.shortcutShift = os.startTimer( prg.shortcutInt )
            elseif e[2] == 45 and prg.ev.shortcutCtrl then
                copySelection()
                deleteSelection()
                editGUI()
                prg.ev.shortcutCtrl = nil
            elseif e[2] == 46 and prg.ev.shortcutCtrl then
                copySelection()
                prg.ev.shortcutCtrl = nil
            elseif e[2] == 48 and prg.ev.shortcutCtrl then
                pasteSelection()
                editGUI()
                prg.ev.shortcutCtrl = nil
            elseif e[2] == 199 then
                local spaces = #prg.file[prg.yScroll+prg.yPos]:match( "^%s*" )

                if prg.xScroll+prg.xPos > spaces+1 then
                    setCursor( spaces+1 )
                else
                    setCursor( 1 )
                end
            elseif e[2] == 200 then
                setCursor( prg.xScroll+prg.xPos, prg.yScroll+prg.yPos-1, false, false, false, true )
            elseif e[2] == 203 then
                setCursor( prg.xPos+prg.xScroll-1 )
            elseif e[2] == 205 then
                setCursor( prg.xPos+prg.xScroll+1 )
            elseif e[2] == 207 then
                setCursor( #prg.file[prg.yScroll+prg.yPos]+1 )
            elseif e[2] == 208 then
                setCursor( prg.xScroll+prg.xPos, prg.yScroll+prg.yPos+1, false, false, false, true )
            elseif e[2] == 211 then
                if prg.sel.x1 ~= 0 then
                    deleteSelection()
                    setCursor( prg.xScroll+prg.xPos, false, false, true )
                elseif prg.xScroll+prg.xPos <= #prg.file[prg.yScroll+prg.yPos] then
                    prg.file[prg.yScroll+prg.yPos] = prg.file[prg.yScroll+prg.yPos]:sub( 1, prg.xScroll+prg.xPos-1 ) .. prg.file[prg.yScroll+prg.yPos]:sub( prg.xScroll+prg.xPos+1 )
                    writeAtPos( prg.offTop+prg.yPos )
                elseif #prg.file > prg.yScroll+prg.yPos then
                    prg.file[prg.yScroll+prg.yPos] = prg.file[prg.yScroll+prg.yPos] .. prg.file[prg.yScroll+prg.yPos+1]
                    table.remove( prg.file, prg.yScroll+prg.yPos+1 )
                    editGUI()
                end
            end
        elseif e[1] == "mouse_click" and e[2] == 1 then
            if e[4] > 0 and e[4] <= prg.offTop then
                local hits = prg.gui.checkHitmap( { hitmap=prg.hitmap, x1=e[3], y1=e[4]  } )

                if hits.file then
                    fileMenu()
                elseif hits.edit then
                    editMenu()
                elseif hits.document then
                    docMenu()
                --[[elseif hits.run then
                    runMenu()]]
                end
            elseif e[4] > prg.offTop and e[3] > width then
                local wholeRefresh
                if prg.sel.x1 ~= 0 then
                    prg.sel.x1, prg.sel.x2, prg.sel.y1, prg.sel.y2 = 0, 0, 0, 0
                    wholeRefresh = true
                end
                prg.lastScroll.x1 = math.min( prg.xScroll+e[3]-width, #( prg.file[prg.yScroll+e[4]-prg.offTop] or "" )+1 )
                prg.lastScroll.y1 = math.min( prg.yScroll+e[4]-prg.offTop, #prg.file )
                setCursor( prg.xScroll+e[3]-width, prg.yScroll+e[4]-prg.offTop, false, wholeRefresh )
            end
        elseif e[1] == "mouse_drag" and e[2] == 1 then
            if e[4] > prg.offTop and e[4] <= #prg.file+prg.offTop and e[3] > width then
                local wholeRefresh, pos1 = nil, math.min( prg.xScroll+e[3]-width, #( prg.file[prg.yScroll+e[4]-prg.offTop] or "" )+1 )

                if prg.yScroll+e[4]-prg.offTop < prg.lastScroll.y1 then
                    prg.sel.x1 = pos1
                    prg.sel.x2 = prg.lastScroll.x1-1
                    wholeRefresh = math.abs( prg.yScroll+e[4]-prg.offTop-prg.sel.y1 ) > 1 and true
                elseif prg.yScroll+e[4]-prg.offTop > prg.lastScroll.y1 then
                    prg.sel.x1 = prg.lastScroll.x1
                    prg.sel.x2 = pos1
                    wholeRefresh = math.abs( prg.yScroll+e[4]-prg.offTop-prg.sel.y2 ) > 1 and true
                elseif prg.xScroll+e[3]-width < prg.lastScroll.x1 then
                    prg.sel.x1 = math.min( prg.lastScroll.x1-1, pos1 )
                    prg.sel.x2 = math.max( prg.lastScroll.x1-1, pos1 )
                else
                    prg.sel.x1 = math.min( prg.lastScroll.x1, pos1 )
                    prg.sel.x2 = math.max( prg.lastScroll.x1, pos1 )
                end

                if e[4] == prg.ySize or e[4] == prg.offTop+1 or e[3] == width+1 or e[3] == prg.xSize then
                    prg.ev.scrollWait = os.startTimer( prg.scrollWait )
                end

                prg.sel.y1 = math.min( prg.yScroll+e[4]-prg.offTop, prg.lastScroll.y1 )
                prg.sel.y2 = math.max( prg.yScroll+e[4]-prg.offTop, prg.lastScroll.y1 )

                if prg.sel.x1 == prg.sel.x2 and prg.sel.x1 == #prg.file[prg.sel.y1]+1 and prg.sel.y1 == prg.sel.y2 then
                    prg.sel.x1, prg.sel.x2, prg.sel.y1, prg.sel.y2 = 0, 0, 0, 0
                    wholeRefresh = false
                end

                setCursor( pos1, prg.yScroll+e[4]-prg.offTop, true, wholeRefresh, false, true )
            end
        elseif e[1] == "mouse_scroll" then
            if e[2] == -1 and prg.yScroll > 0 then
                prg.yScroll = prg.yScroll + e[2]

                if prg.yPos < prg.ySize-prg.offTop then
                    prg.yPos = prg.yPos + 1
                end

                setCursor( prg.xScroll+prg.xPos, false, false, false, true)
                editGUI()
            elseif e[2] == 1 and prg.yScroll < #prg.file-prg.ySize+prg.offTop then
                prg.yScroll = prg.yScroll + e[2]

                if prg.yPos > 1 then
                    prg.yPos = prg.yPos - 1
                end

                setCursor( prg.xScroll+prg.xPos, false, false, false, true)
                editGUI()
            end
        elseif e[1] == "paste" then
            prg.file[prg.yScroll+prg.yPos] = prg.file[prg.yScroll+prg.yPos]:sub( 1, prg.xScroll+prg.xPos-1 ) .. e[2] .. prg.file[prg.yScroll+prg.yPos]:sub( prg.xScroll+prg.xPos )
            setCursor( prg.xScroll+prg.xPos+#e[2], false, true )
        end
    end
end
--[[ MAIN LOOP END ]]--


--[[ ERROR CATCHING ]]--
if prg.running then
    local _, err = pcall( main )
    if err then
        term.setBackgroundColor( 32768 )
        term.setTextColor( 16384 )
        print( "Oh noes! xEdit seems to have crashed :s\nPlease post a detailled bug report on the ComputerCraft forums\n" .. err .. "\n" )
        term.setTextColor( 1 )
    else
        exitScreen()
    end
else
    exitScreen()
end
--[[ ERROR CATCHING END ]]--
